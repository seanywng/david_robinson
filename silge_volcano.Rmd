---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidymodels)
library(themis)
library(vip)
theme_set(theme_minimal())

# disabling scientific notation
options(scipen = 999)

volcano_raw <- readr::read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-12/volcano.csv")

```

```{r}
glimpse(volcano_raw)

volcano_raw %>%
  count(primary_volcano_type, sort = TRUE)
```

```{r}
volcano_df <- volcano_raw %>% 
  transmute(volcano_type = case_when(str_detect(primary_volcano_type, "Stratovolcano") ~ "stratovolcano", 
                                     str_detect(primary_volcano_type, "Shield") ~ "shield", 
                                     TRUE ~ "other"),
            volcano_number, latitude, longitude, tectonic_settings, major_rock_1, elevation) %>% 
  mutate_if(is.character, factor)
```

```{r}
world <- map_data("world")

ggplot() +
  geom_map(data = world, map = world, aes(x = long, y = lat, map_id = region), colour = "white", fill = "gray50", alpha = 0.2) +
  geom_point(data = volcano_df, aes(x = longitude, y = latitude, colour = volcano_type), alpha = 0.8)
```


```{r}

volcano_boot <- bootstraps(volcano_df)
volcano_boot
```

```{r}
volcano_df %>% count(volcano_type)

# the smote algorithm generates new examples of whatever class you have using nearest neighbour

volcano_rec <- recipe(volcano_type ~ ., data = volcano_df) %>% 
  update_role(volcano_number, new_role = "Id") %>% 
  step_other(tectonic_settings) %>% 
  step_other(major_rock_1) %>% 
  step_dummy(tectonic_settings, major_rock_1) %>% # this is a pivot_wider with 1s and 0s for these categories
  step_zv(all_predictors()) %>% # zv is zero variance
  step_normalize(all_predictors()) %>% 
  step_smote(volcano_type)
```

```{r}
volcano_prep <- prep(volcano_rec) # preprocessing it trains and carries out all the instructions
juice(volcano_prep) # juicing it shows you the output of the prep


```

```{r}
rf_spec <- rand_forest(trees = 1000) %>% 
  set_mode("classification") %>% 
  set_engine("ranger") # ranger works for multinomial out of the box

# a workflow is a way to make the recipe and the model stick together
# you can fit a workflow much like you would fit a model 
volcano_wf <- workflow() %>%  
  add_recipe(volcano_rec) %>% 
  add_model(rf_spec)
```

```{r}
volcano_res <- fit_resamples(
  volcano_wf, 
  resamples = volcano_boot,
  control = control_resamples(save_pred = TRUE)
)
```

```{r}
volcano_res %>% 
  collect_metrics()

volcano_res %>% 
  collect_predictions() %>% 
  conf_mat(volcano_type, .pred_class)

volcano_res %>% 
  collect_predictions() %>% 
  ppv(volcano_type, .pred_class)

volcano_res %>% 
  collect_predictions() %>%
  group_by(id) %>% 
  ppv(volcano_type, .pred_class) %>% 
  ggplot(aes(x = .estimate)) + 
  geom_histogram(bins = 10)
```

```{r}


# much like you can fit a model and a workflow, you can also fit a model specification 
rf_spec %>% 
  set_engine("ranger", importance = "permutation") %>% 
  fit(
    volcano_type ~ ., 
    data = juice(volcano_prep) %>% 
      select(-volcano_number) %>% 
      janitor::clean_names()
  ) %>% 
  vip(geom = "point")
```

```{r}
volcano_pred <- volcano_res %>% 
  collect_predictions() %>% 
  mutate(correct  = volcano_type == .pred_class) %>% 
  left_join(volcano_df %>% 
              mutate(.row = row_number()))
```


```{r}
ggplot() +
  geom_map(data = world, map = world, aes(x = long, y = lat, map_id = region), colour = "white", fill = "gray50", alpha = 0.2) +
  stat_summary_hex(data = volcano_pred, 
                 aes(x = longitude, y = latitude, z = as.integer(correct)),
                 fun = "mean",
                 alpha = 0.7, bins = 60) +
  scale_fill_gradient(high = "cyan3", labels = scales::percent) +
  labs(fill = "percent classfied\ncorrectly")
```

